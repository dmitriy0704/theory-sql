# Введение в SQL

## Стандарт SQL

_Можно выделить следующие преимущества языка SQL:_

1) независимость от конкретной СУБД. Несмотря на наличие диалектов и различий в
   синтаксисе, в большинстве своём SQL-запросы могут быть достаточно легко
   перенесены из одной СУБД в другую. Естественно, что при применении некоторых
   специфичных для реализации возможностей такой переносимости добиться уже
   очень трудно;
2) наличие стандартов. Наличие стандартов и набора тестов для выявления
   совместимости и соответствия конкретной реализации SQL общепринятому
   стандарту способствует «стабилизации» языка. Правда, стоит обратить внимание,
   что сам по себе стандарт местами слишком формализован;
3) декларативность. С помощью SQL программист описывает только то, какие данные
   нужно извлечь или модифицировать. То, каким образом это сделать, решает СУБД
   непосредственно при обработке SQL-зaпpoca. Но, конечно, полезно представлять,
   как СУБД будет разбирать текст запроса. Чем сложнее сконструирован запрос,
   тем больше он допускает вариантов написания, различных по скорости
   выполнения, но одинаковых по итоговому набору данных.

К недостаткам языка SQL можно отнести следующие:

1) несоответствие реляционной модели данных. Создатели реляционной модели и их
   сторонники указывают на то, что SQL не является истинно реляционным языком. В
   частности, они указывают на следующие дефекты SQL с точки зрения
   реляционной теории:
    - допущение строк-дубликатов в таблицах и результатах выборок, что в рамках
      реляционной модели данных невозможно и недопустимо;
    - поддержка неопределённых значений (NULL), создающая фактически
      многозначную логику;
    - значимость порядка столбцов, возможность ссылок на столбцы по номерам (в
      реляционной модели столбцы должны быть равноправны); допущение столбцов
      без имени, дублирующихся имён столбцов;

2) сложность языка. Хотя SQL и задумывался как средство работы конечного
   пользователя, позже он стал настолько сложным, что превратился в инструмент
   программиста;
3) отступления от стандартов. Несмотря на наличие международного стандарта ANSI,
   многие разработчики СУБД вносят изменения в язык SQL, применяемый в СУБД,
   тем самым отступая от стандарта. Таким образом появляются специфичные для
   каждой конкретной СУБД диалекты языка SQL;
4) сложность работы с иерархическими структурами. Ранее диалекты SQL большинства
   СУБД не предлагали способа манипуляции древовидными структурами. Некоторые
   поставщики СУБД предлагали свои решения. В настоящее время в ANSI
   стандартизована рекурсивная конструкция WITH.

## Типы данных в SQL

### Точные числовые типы

Точные числовые типы предназначены для обработки целочисленных значений и
значений, имеющих дробную часть, без потерь точности. При задании такого типа
данных необходимо указать два аргумента: точность (n) и масштаб (m). Точность
задает общее число значащих цифр, используемых при отображении числа. Масштаб
определяет число значащих цифр справа от десятичной точки.

- NUМERIC `[(n[,m])]` - Точное число, описываемое аргументами n и m.
- DECIMAL `[(n[,m])]` или DEC `[(n[,m])]` - В отличие от NUМERIC, способно
  хранить
  число дальше с большей точностью, чем определено в аргументе m. Поэтому
  говорят, что NUMERIC задает реальное значение точности, а DECIМAL -
  минимальное значение точности.
- BIGINT - Тип данных, предназначен для хранения больших целых чисел (обычно 64
  бит). Типы данных ВIGINT, INTEGER и SМALLINT являются частным случаем типа
  данных NUМERIC, у которого масштаб установлен в О, а точность определена
  возможностями СУБД.
- INТEGER или INT - Тип данных, предназначен для хранения целых чисел (обычно 32
  бит).
- SМALLINT - Тип данных, предназначен для хранения малых целых чисел (обычно 16
  бит).

### Приближенные числовые типы

Приближенные числовые типы представляют собой тип дан ных для определения чисел
с плавающей точкой, осуществляющий хранение числа в научном формате (мантисса
плюс порядок)  
Типы данных real и double precision хранят приближённые числовые значения с
переменной точностью. Обычно эти типы реализуют стандарт для двоичной арифметики
с плавающей точкой (с одинарной и двойной точностью соответственно), в той мере,
в какой его поддерживают процессор, операционная система и компилятор.  
Неточность здесь выражается в том, что некоторые значения, которые нельзя
преобразовать во внутренний формат, сохраняются приближённо, так что полученное
значение может несколько отличаться от записанного.

**_Приближенные числовые типы:**_

- `REAL` - Точность и предел значений зависят от СУБД. Как правило, занимает в
  памяти 6 байт и в состоянии хранить число в интервале от -3,4Е-38 до +3,4Е+38
  с точностью до 7 цифр после запятой.
- `FLOAT [(n)]` - Аргументом n определяется минимальное значение точности.
  Обычно подразумевается хранение чисел с одинарной точностью, 4 байта.
- `DOUВLE PRECISION` Точность определяется версией СУБД, превышает точность REAL
  (обычно, 8 байт). Тип данных способен хранить число в интервале от 1,7Е
  -308до+1,7Е - 308.

### Логический тип

Логический тип данных языка SQL отличается от соответствующего типа в
стандартных языках программирования. Особенность заключается в том, что два
классических элемента (true/ false) булевой логики здесь дополнены третьим
значением - неопределенностью Unknown (или NULL). Как следствие логика
становится более сложной - трехзначной.

### Строковые типы данных

CHAR представляет собой строку фиксированной длины. Если в поле типа CHAR
записывается текстовое значение меньшего размера, чем размерность поля, то
оставшиеся позиции символов заполнятся пробелами.

VARCHAR представляет собой строку переменной длины. Преимущество такого типа
данных над типом CHAR заключается в том, что здесь пустые позиции не заполняются
пробелами и, соответственно, таблица требует меньшего размера оперативной и
дисковой памяти.

**_Строковые типы:**_

- `CНARACTER [n], или сокращенно CHAR[n]` - Тип данных предназначен для создания
  текстовой И фиксированной длины, дополненная пробелами. Количество символов в
  строке определяется в квадратных скобках после указания типа данных.
- `CНARACTER VARYNG[n], или сокращенно VARCНAR[n]` - Текстовая строка переменной
  длины. Максимальный размер строки определяется в квадратных скобках.
- `NCНAR[n], NCНAR VARYING[n](NAТIONAL)` - Строки национального символьного
  набора. При использовании следует указать спецификацию набора символов,
  воспользовавшись командой СНАRАСТЕR SЕТ.
- `(NAТIONAL) СНАRАСTER LARGE OBJECT [n], или CLOB[n]` - Предназначен для
  определения столбцов таблиц, хранящих большие группы символов.
- `ТЕХТ`

### Битовые последовательности

Битовая последовательность предназначена для хранения любой двоичной информации.
Тип данных универсален и позволяет описывать как простейшие логические данные,
так и сложные объекты, например, файлы мультимедиа.

Так же, как и для строковых типов данных, поддерживаются
битовые последовательности фиксированной длины, переменной
длины и последовательности, предназначенные для хранения больших объектов (
таблица 4.5). Особенность типа данных фиксирован
ной длины BIT состоит в том, что попытка записать в поле этого
типа значения меньшей длины, чем указано в аргументе n, приведет
к ошибке.

**_Битовые последовательности_**

- `ВIT[n]` Битовая последовательноС1ъ фиксированной длины. Аргумент n
  устанавливает длину последовательности в битах. Если аргумент отсутствует (или
  установлен в 1), то тип данных используется для полей логического типа.
- `ВIT VARYNG [n]` Битовая последовательность переменной длины, n - максимальное
  значение битовой последовательности.
- `ВINARУ LARGE OBJECT [n], BLOB [n]` - Тип данных предназначен для хранения
  больших объектов. Например, файлов мультимедиа и изображений.

### Дата и время

За описание значений даты и времени отвечает пять типов данных. Соответственно,
можно хранить только дату, только время, дату и время одновременно, а также
дополнительно можно указать временную зону (таблица 4.6). Дата представляется
в формате общепринятого в большинстве стран мира григорианского календаря.

`DATE`
Тип данных включает три поля: YEAR (год)- от 0001 до 9999; MONTH (месяц) - от
01 до 12; DAY (день) - от 01 до 31. Формат записи: «yyyy-mm-dd».

`ТIМЕ [(n)]` Тип данных включает три поля: HOUR (часы), МINUТE (минуты),
SECOND (секунды). Если аргумент точности (n) не определен, то полное число
позиций (вместе с разделителями) равно 8. Формат записи: «hh:mm:ss».

`ТIМЕSТАМР [(n)]` Метка даты-времени, представляющая собой комбинацию типов
данных DATE и ТIМЕ.

`ТIМE WITH ТIМEZONE`  Тип данньrх аналогичен ТIМЕ плюс два дополнительных
значения, характеризующих смещение от Гринвичского меридиана в часах
ТIМEZONE_HOUR и минутах ТIМEZONE МINUТE.

`ТIМЕSТАМР WITHТIМE ZONE` Метка даты-времени плюс смещение от Гринвича.

### Непредопределенные типы данных

Большинство нестандартных, или, как их еще называют, не предопределенных типов
данных, вошло в состав SQL сравнительно недавно. В SQL:l999 появилась
спецификация коллекции и массива, а в SQL:2003 к стандарту добавилось
мультимножество. Кроме того, стандарт добавил такие типы, как
последовательности, пользовательский тип, тип данных XML, JSON и ссылочный тип.
Основная особенность непредопределенных типов в том, что даже в действующем
стандарте SQL их называют типами данных, не соответствующими SQL. Несоответствий
много, но главное - нарушение требования к атомарности данных, которое
предписывает, чтобы в одной ячейке таблицы хранилось единственное неделимое
значение.

## Встроенные функции

- `ВIT_LЕNGТН(битовая строка)` - Возвращает длину строки в битах.
- `САSТ(значение AS тип данных)` - Функция преобразования исходного значения к
  новому типу данных.
- `CНAR_LENGTН(символьная строка)` - Возвращает длину строки в символах.
- `CURRENT DATE` - Возвращает текущую дату.
- `СURRЕNТ_ТТМЕ(точность)` - Возвращает текущее время с указанной точностью.
- `CURRENT_TTМESTAМP(тoчность)` - Возвращает текущую дату и время с указанной
  точностью.
- `LOWER(cтpoкa)` - Преобразование текстовой строки к нижнему регистру.
- `POSITION(подстрока IN строка)` - Возвращает позицию, с которой начинается
  вхождение подстроки в строку.
- `SUВSTRING( строка FROM n FOR длина)` - Возвращает часть строки, начиная с
  n-го символа с указанной длиной.
- `TRANSLATE(cтpoкa USING функция)` - Преобразование строки с использованием
  указанной функции.
- `TRIM(LEADING | ТRAILING | ВОТН символ FROM строка) ` - Удаление из строки
  всех первых (LEADING), последних (TRAILING) или первых и последних (ВОТН)
  символов.
- `UPPER(строка)` - Преобразование текстовой строки к верхнему регистру.

# SQL. ОПЕРАТОРЫ ОПРЕДЕЛЕНИЯ ДАННЫХ (Data Definition Language, DDL).

Эти операторы позволяют создавать, редактировать и удалять основные объекты БД,
такие, как схемы, домены, таблицы и т. д. За создание, изменение и удаление
объекта БД отвечают три команды CREATE, ALTER и DROP соответственно.

## Базы данных

Для создания базы данных используется команда CREATE
DATABASE. Она имеет следующий синтаксис:

```
CREATE DATAВASE [IF NOT EXISTS] <имя базы даных>;
```

Соответственно, у команды есть две формы. Первая форма CREATE DATABASE
попытается создать базу данных, но если такая база данных уже существует, то
операция возвратит ошибку. Вторая форма CREATE DATABASE IF NOT EXISTS попытается
создать базу данных, если на сервере отсутствует база с таким именем.

В стандарте SQL вместо CREATE DATABASE предусмотрена синтаксическая конструкция
CREATE SСНЕМА, которая имеет следующий формальный вид:

    CREATE SСНЕМА <имя схемы> 
        [AUTHORIZATION имя владельца]
            [DEFAULT CНARTERSET набор символов по умолчанию]
                [РАТИ <символьный путь к файлам БД>]  
                [<дополнительные инструкции> ... ]

Для базы удаления базы данных применяется команда
DROP DATABASE, которая имеет следующий синтаксис:

    DROP DATAВASE [IF EXISTS] <имя базы даных>;

или

    DROP SСНЕМА <имя_схемы> [CASCADEIRESTRICT];

## Таблицы

### Создание таблиц

`CREATE ТABLE`:

    CREATE ТАВLЕ <название_таблицы> (  
        название столбца1 <тип данных> <атрибуты_1>,
        название столбца2 <тип данных> <атрибуты_2>,
        ...
        название столбцаN <тип данных> <атрибуты_N>,
        атрибуты_уровня_таблицы
    );

**_Атрибуты столбцов_**

- `NOTNULL` - Запрет на вставку в столбец неопределенного значения NULL.
- `UNIQUE` - Значение столбца должно быть уникальным.
- `AUTO_INCREМENT` - Значение столбца будет автоматически увеличиваться при
  добавлении новой строки.
- `DEFAULT` - Определяет значение по умолчанию для столбца.
- `PRIМARY КEY` - Признак первичного ключа. Значение поля должно быть
  уникальным,
  оно не может содержать NULL, в таблице это ограничение может использоваться
  только один раз.
- `СНЕСК` - Ограничение-проверка на допустимое значение. В скобках за оператором
  СНЕСК указывается предикат, проверяющий допустимость значения.
- `FOREIGN КEY` - Ограничение внешнего ключа для таблицы. Ограничения внешнего
  ключа требуют, чтобы все значения, присутствующие во внешнем ключе,
  соответствовали значениям родительского ключа (обеспечение ссылочной
  целостности)

_Пример создания таблицы с использованием дополнительных атрибутов._

    CREATE ТАВLЕ customers (
        id INT PRIМARY КЕУ AUTO_INCREМENT,
        age INT DEFAULT 18 CHECK(age > О AND age < 100) ,
        first_name VARCНAR(20) NOT NULL,
        last name VARCНAR(20) NOT NULL,
        email VARCНAR(ЗO) NULL,
        phone VARCНAR(20) UNIQUE,
        СНЕСК ( (email != '') AND (phone != ''))
    );

В примере создается таблица customers с указанием, что столбец id является
первичным ключом. Кроме того, этот столбец является автоинкрементным, т.е. явно
задавать значение идентификатора не требуется, значение столбца i d после каждой
новой добавленной строки будет увеличиваться на единицу. Для столбца age указан
атрибут DEFAULT, т.е. если явно не указать значение этого столбца при добавлении
новых данных, по умолчанию будет добавлено значение 18. Кроме того, у столбца
age указан атрибут СНЕСК, после которого добавлено условие, что возраст клиентов
должен быть больше О и меньше 100. Также СНЕСК можно использовать на уровне
таблицы. В данном примере проверяется, что текстовые поля заполнены. Далее
указано, что имя и фамилия клиента не могут содержать неопределенные значения
NULL. Столбец phone, который представляет телефон клиента, может хранить только
уникальные значения. Т.е. будет нельзя добавить в таблицу две строки, у которых
значения в этом столбце будут совпадать. Рассмотрим еще один пример с заданием
первичного ключа таблицы. Первичный ключ уникально идентифицирует строку в
таблице. Первичный ключ может быть установлен как на уровне столбца, так и на
уровне таблицы. Первичный ключ также может быть составным:такой ключ будет
использовать сразу несколько столбцов, чтобы уникально идентифицировать строку в
таблице. В следующем примере составной ключ создается для таблицы заказов
orders.

    CREATE ТАВLЕ orders
        order_id INT,
        product_id INT,
        quantity INT,
        price DECIМAL(lO, 2),
        PRIМARY КЕУ (order id, product id)
    ) ;

В таблице поля order id и product id вместе выступают как составной первичный
ключ. То есть в таблице orders не может быть двух строк, где для обоих из этих
полей одновременно были бы одни и те же значения. Таким же образов на уровне
таблицы можно указывать атрибуты СНЕСК и UNIQUE.